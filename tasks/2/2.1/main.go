package main

import "fmt"

func main() {
	// инициализируем слайс int
	numbers := []int{2, 4, 6, 8, 10}
	// создаем небуферизированный канал, принимающий int
	out := make(chan int)
	/*
		выполняем отложенный вызов (закрытие канала)
		отложенный вызов выполняется перед выходом из функции
		важно помнить, что отложенные вызовы выполняются по принципу LIFO
	*/
	defer close(out)
	// проходимся циклом по numbers
	for _, num := range numbers {
		/*
			вызываем анонимную функцию в отдельной горутине
			и передаем аргумент в параметр функции
			*при каждой итерации создается новая горутина,
			в нашем примере у нас будет создано 5 горутин
		*/
		go func(num int) {
			/*
				кладем в канал out результат вычисления квадрата (условное объяснение)
				! Если recvq не пуст, то мы достаем из списка recvq sudog, где хранится горутина получателья,
				и поле elem с адресом, куда нужно записать данные.
				Если список recvq пуст, то в поле sendq добавляется структура sudog, в которой хранится горутина и данные, которые должен забрать получатель.
				После наша горутина засыпает (вызов функции gopark()) и у неё меняется состояние из running в waiting.
			*/
			out <- num * num
		}(num)
	}
	/*
		так как мы знаем количество значений, которые будут отправлены в канал,
		то мы итерируемся столько же раз (5 раз)
	*/
	for range numbers {
		/*
			достаем данные из канала и выводим их в stdout (условное объяснение)
			! у небуферизованного канала нет хранилища для данных (буфера),
			мы получаем данные напрямую из стека другой горутины, которая находится в очереди sendq,
			и меняем её статус на runnable, и она попадает в очередь runq.
			если для получателей пока нет данных, то наша (func main) горутина попадает в очередь recvq и засыпает gopark().
		*/
		fmt.Println(<-out)
	}
}

/*
	sendq и recvq - это связанный список из структур sudog
	sudog имеет два поля
	type sudog struct{
		G - указывает на горутину, связанную с этой сущностью управления горутиной.
		elem - хранит адрес ячейки памяти, куда нужно положить данные/хранит данные, которые получатель должен забрать
	}
	Таким образом, sendq и recvq представляют собой списки sudog для горутин, ждущих отправки
	или получения данных
*/
